/**
 * @preserve XDate v@VERSION
 * Docs & Licensing: http://arshaw.com/xdate/
 */

var XDate = function (Date, Math, Array, undefined) {
	var FULLYEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOURS = 3;
	var MINUTES = 4;
	var SECONDS = 5;
	var MILLISECONDS = 6;
	var DAY = 7;
	var YEAR = 8;
	var WEEK = 9;
	var DAY_MS = 86400000;
	var ISO_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss(.fff)";
	var ISO_FORMAT_STRING_TZ = ISO_FORMAT_STRING + "zzz";

	var methodSubjects = ['FullYear', 'Month', 'Date', 'Hours', 'Minutes', 'Seconds', 'Milliseconds', 'Day', 'Year'];
	var subjectPlurals = ['Years', 'Months', 'Days'];
	var unitsWithin = [12, 31, 24, 60, 60, 1000, 1];
	var formatStringRE = new RegExp("(([a-zA-Z])\\2*)|" + "(\\(" + "(('.*?'|\\(.*?\\)|.)*?)" + "\\))|" + "('(.*?)')");
	var UTC = Date.UTC;
	var toUTCString = Date.prototype.toUTCString;
	var proto = XDate.prototype;

	proto.length = 1;
	proto.splice = Array.prototype.splice;

	function XDate() {
		return init(this instanceof XDate ? this : new XDate(), arguments);
	}

	function init(xdate, args) {
		var len = args.length;
		var utcMode;
		if (isBoolean(args[len - 1])) {
			utcMode = args[--len];
			args = slice(args, 0, len);
		}
		if (!len) {
			xdate[0] = new Date();
		} else if (len == 1) {
			var arg = args[0];
			if (arg instanceof Date) {
				xdate[0] = new Date(arg.getTime());
			} else if (isNumber(arg)) {
				xdate[0] = new Date(arg);
			} else if (arg instanceof XDate) {
				xdate[0] = _clone(arg);
			} else if (isString(arg)) {
				xdate[0] = new Date(0);
				xdate = parse(arg, utcMode || false, xdate);
			}
		} else {
			xdate[0] = new Date(UTC.apply(Date, args));
			if (!utcMode) {
				xdate[0] = coerceToLocal(xdate[0]);
			}
		}
		if (isBoolean(utcMode)) {
			setUTCMode(xdate, utcMode);
		}
		return xdate;
	}

	proto.getUTCMode = methodize(getUTCMode);
	function getUTCMode(xdate) {
		return xdate[0].toString === toUTCString;
	};

	proto.setUTCMode = methodize(setUTCMode);
	function setUTCMode(xdate, utcMode, doCoercion) {
		if (utcMode) {
			if (!getUTCMode(xdate)) {
				if (doCoercion) {
					xdate[0] = coerceToUTC(xdate[0]);
				}
				xdate[0].toString = toUTCString;
			}
		} else {
			if (getUTCMode(xdate)) {
				if (doCoercion) {
					xdate[0] = coerceToLocal(xdate[0]);
				} else {
					xdate[0] = new Date(xdate[0].getTime());
				}
			}
		}
		return xdate;
	}

	proto.getTimezoneOffset = function () {
		if (getUTCMode(this)) {
			return 0;
		} else {
			return this[0].getTimezoneOffset();
		}
	};

	each(methodSubjects, function (subject, fieldIndex) {

		proto['get' + subject] = function () {
			return _getField(this[0], getUTCMode(this), fieldIndex);
		};

		if (fieldIndex != YEAR) {

			proto['getUTC' + subject] = function () {
				return _getField(this[0], true, fieldIndex);
			};
		}

		if (fieldIndex != DAY) {

			proto['set' + subject] = function (value) {
				_set(this, fieldIndex, value, arguments, getUTCMode(this));
				return this;
			};

			if (fieldIndex != YEAR) {

				proto['setUTC' + subject] = function (value) {
					_set(this, fieldIndex, value, arguments, true);
					return this;
				};

				proto['add' + (subjectPlurals[fieldIndex] || subject)] = function (delta, preventOverflow) {
					_add(this, fieldIndex, delta, preventOverflow);
					return this;
				};

				proto['diff' + (subjectPlurals[fieldIndex] || subject)] = function (otherDate) {
					return _diff(this, otherDate, fieldIndex);
				};
			}
		}
	});

	function _set(xdate, fieldIndex, value, args, useUTC) {
		var getField = curry(_getField, xdate[0], useUTC);
		var setField = curry(_setField, xdate[0], useUTC);
		var expectedMonth;
		var preventOverflow = false;
		if (args.length == 2 && isBoolean(args[1])) {
			preventOverflow = args[1];
			args = [value];
		}
		if (fieldIndex == MONTH) {
			expectedMonth = (value % 12 + 12) % 12;
		} else {
			expectedMonth = getField(MONTH);
		}
		setField(fieldIndex, args);
		if (preventOverflow && getField(MONTH) != expectedMonth) {
			setField(MONTH, [getField(MONTH) - 1]);
			setField(DATE, [getDaysInMonth(getField(FULLYEAR), getField(MONTH))]);
		}
	}

	function _add(xdate, fieldIndex, delta, preventOverflow) {
		delta = Number(delta);
		var intDelta = Math.floor(delta);
		xdate['set' + methodSubjects[fieldIndex]](xdate['get' + methodSubjects[fieldIndex]]() + intDelta, preventOverflow || false);
		if (intDelta != delta && fieldIndex < MILLISECONDS) {
			_add(xdate, fieldIndex + 1, (delta - intDelta) * unitsWithin[fieldIndex], preventOverflow);
		}
	}

	function _diff(xdate1, xdate2, fieldIndex) {
		xdate1 = xdate1.clone().setUTCMode(true, true);
		xdate2 = XDate(xdate2).setUTCMode(true, true);
		var v = 0;
		if (fieldIndex == FULLYEAR || fieldIndex == MONTH) {
			for (var i = MILLISECONDS, methodName; i >= fieldIndex; i--) {
				v /= unitsWithin[i];
				v += _getField(xdate2, false, i) - _getField(xdate1, false, i);
			}
			if (fieldIndex == MONTH) {
				v += (xdate2.getFullYear() - xdate1.getFullYear()) * 12;
			}
		} else if (fieldIndex == DATE) {
			var clear1 = xdate1.toDate().setUTCHours(0, 0, 0, 0);
			var clear2 = xdate2.toDate().setUTCHours(0, 0, 0, 0);
			v = Math.round((clear2 - clear1) / DAY_MS) + (xdate2 - clear2 - (xdate1 - clear1)) / DAY_MS;
		} else {
			v = (xdate2 - xdate1) / [3600000, 60000, 1000, 1][fieldIndex - 3];
		}
		return v;
	}

	proto.getWeek = function () {
		return _getWeek(curry(_getField, this, false));
	};

	proto.getUTCWeek = function () {
		return _getWeek(curry(_getField, this, true));
	};

	proto.setWeek = function (n, year) {
		_setWeek(this, n, year, false);
		return this;
	};

	proto.setUTCWeek = function (n, year) {
		_setWeek(this, n, year, true);
		return this;
	};

	proto.addWeeks = function (delta) {
		return this.addDays(Number(delta) * 7);
	};

	proto.diffWeeks = function (otherDate) {
		return _diff(this, otherDate, DATE) / 7;
	};

	function _getWeek(getField) {
		return getWeek(getField(FULLYEAR), getField(MONTH), getField(DATE));
	}

	function getWeek(year, month, date) {
		var d = new Date(UTC(year, month, date));
		var week1 = getWeek1(getWeekYear(year, month, date));
		return Math.floor(Math.round((d - week1) / DAY_MS) / 7) + 1;
	}

	function getWeekYear(year, month, date) {
		var d = new Date(UTC(year, month, date));
		if (d < getWeek1(year)) {
			return year - 1;
		} else if (d >= getWeek1(year + 1)) {
			return year + 1;
		}
		return year;
	}

	function getWeek1(year) {
		var d = new Date(UTC(year, 0, 4));
		d.setUTCDate(d.getUTCDate() - (d.getUTCDay() + 6) % 7);
		return d;
	}

	function _setWeek(xdate, n, year, useUTC) {
		var getField = curry(_getField, xdate, useUTC);
		var setField = curry(_setField, xdate, useUTC);

		if (year === undefined) {
			year = getWeekYear(getField(FULLYEAR), getField(MONTH), getField(DATE));
		}

		var week1 = getWeek1(year);
		if (!useUTC) {
			week1 = coerceToLocal(week1);
		}

		xdate.setTime(week1.getTime());
		setField(DATE, [getField(DATE) + (n - 1) * 7]);
	}

	XDate.parsers = [parseISO];

	XDate.parse = function (str) {
		return +XDate('' + str);
	};

	function parse(str, utcMode, xdate) {
		var parsers = XDate.parsers;
		var i = 0;
		var res;
		for (; i < parsers.length; i++) {
			res = parsers[i](str, utcMode, xdate);
			if (res) {
				return res;
			}
		}
		xdate[0] = new Date(str);
		return xdate;
	}

	function parseISO(str, utcMode, xdate) {
		var m = str.match(/^(\d{4})(-(\d{2})(-(\d{2})([T ](\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/);
		if (m) {
			var d = new Date(UTC(m[1], m[3] ? m[3] - 1 : 0, m[5] || 1, m[7] || 0, m[8] || 0, m[10] || 0, m[12] ? Number('0.' + m[12]) * 1000 : 0));
			if (m[13]) {
				if (m[14]) {
					d.setUTCMinutes(d.getUTCMinutes() + (m[15] == '-' ? 1 : -1) * (Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0)));
				}
			} else {
				if (!utcMode) {
					d = coerceToLocal(d);
				}
			}
			return xdate.setTime(d.getTime());
		}
	}

	proto.toString = function (formatString, settings, uniqueness) {
		if (formatString === undefined || !valid(this)) {
			return this[0].toString();
		} else {
			return format(this, formatString, settings, uniqueness, getUTCMode(this));
		}
	};

	proto.toUTCString = proto.toGMTString = function (formatString, settings, uniqueness) {
		if (formatString === undefined || !valid(this)) {
			return this[0].toUTCString();
		} else {
			return format(this, formatString, settings, uniqueness, true);
		}
	};

	proto.toISOString = function () {
		return this.toUTCString(ISO_FORMAT_STRING_TZ);
	};

	XDate.defaultLocale = '';
	XDate.locales = {
		'': {
			monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
			monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
			dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
			dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
			amDesignator: 'AM',
			pmDesignator: 'PM'
		}
	};
	XDate.formatters = {
		i: ISO_FORMAT_STRING,
		u: ISO_FORMAT_STRING_TZ
	};

	function format(xdate, formatString, settings, uniqueness, useUTC) {

		var locales = XDate.locales;
		var defaultLocaleSettings = locales[XDate.defaultLocale] || {};
		var getField = curry(_getField, xdate, useUTC);

		settings = (isString(settings) ? locales[settings] : settings) || {};

		function getSetting(name) {
			return settings[name] || defaultLocaleSettings[name];
		}

		function getFieldAndTrace(fieldIndex) {
			if (uniqueness) {
				var i = (fieldIndex == DAY ? DATE : fieldIndex) - 1;
				for (; i >= 0; i--) {
					uniqueness.push(getField(i));
				}
			}
			return getField(fieldIndex);
		}

		return _format(xdate, formatString, getFieldAndTrace, getSetting, useUTC);
	}

	function _format(xdate, formatString, getField, getSetting, useUTC) {
		var m;
		var subout;
		var out = '';
		while (m = formatString.match(formatStringRE)) {
			out += formatString.substr(0, m.index);
			if (m[1]) {
				out += processTokenString(xdate, m[1], getField, getSetting, useUTC);
			} else if (m[3]) {
				subout = _format(xdate, m[4], getField, getSetting, useUTC);
				if (parseInt(subout.replace(/\D/g, ''), 10)) {
					out += subout;
				}
			} else {
				out += m[7] || "'";
			}
			formatString = formatString.substr(m.index + m[0].length);
		}
		return out + formatString;
	}

	function processTokenString(xdate, tokenString, getField, getSetting, useUTC) {
		var end = tokenString.length;
		var replacement;
		var out = '';
		while (end > 0) {
			replacement = getTokenReplacement(xdate, tokenString.substr(0, end), getField, getSetting, useUTC);
			if (replacement !== undefined) {
				out += replacement;
				tokenString = tokenString.substr(end);
				end = tokenString.length;
			} else {
				end--;
			}
		}
		return out + tokenString;
	}

	function getTokenReplacement(xdate, token, getField, getSetting, useUTC) {
		var formatter = XDate.formatters[token];
		if (isString(formatter)) {
			return _format(xdate, formatter, getField, getSetting, useUTC);
		} else if (isFunction(formatter)) {
			return formatter(xdate, useUTC || false, getSetting);
		}
		switch (token) {
			case 'fff':
				return zeroPad(getField(MILLISECONDS), 3);
			case 's':
				return getField(SECONDS);
			case 'ss':
				return zeroPad(getField(SECONDS));
			case 'm':
				return getField(MINUTES);
			case 'mm':
				return zeroPad(getField(MINUTES));
			case 'h':
				return getField(HOURS) % 12 || 12;
			case 'hh':
				return zeroPad(getField(HOURS) % 12 || 12);
			case 'H':
				return getField(HOURS);
			case 'HH':
				return zeroPad(getField(HOURS));
			case 'd':
				return getField(DATE);
			case 'dd':
				return zeroPad(getField(DATE));
			case 'ddd':
				return getSetting('dayNamesShort')[getField(DAY)] || '';
			case 'dddd':
				return getSetting('dayNames')[getField(DAY)] || '';
			case 'M':
				return getField(MONTH) + 1;
			case 'MM':
				return zeroPad(getField(MONTH) + 1);
			case 'MMM':
				return getSetting('monthNamesShort')[getField(MONTH)] || '';
			case 'MMMM':
				return getSetting('monthNames')[getField(MONTH)] || '';
			case 'yy':
				return (getField(FULLYEAR) + '').substring(2);
			case 'yyyy':
				return getField(FULLYEAR);
			case 't':
				return _getDesignator(getField, getSetting).substr(0, 1).toLowerCase();
			case 'tt':
				return _getDesignator(getField, getSetting).toLowerCase();
			case 'T':
				return _getDesignator(getField, getSetting).substr(0, 1);
			case 'TT':
				return _getDesignator(getField, getSetting);
			case 'z':
			case 'zz':
			case 'zzz':
				return useUTC ? 'Z' : _getTZString(xdate, token);
			case 'w':
				return _getWeek(getField);
			case 'ww':
				return zeroPad(_getWeek(getField));
			case 'S':
				var d = getField(DATE);
				if (d > 10 && d < 20) return 'th';
				return ['st', 'nd', 'rd'][d % 10 - 1] || 'th';
		}
	}

	function _getTZString(xdate, token) {
		var tzo = xdate.getTimezoneOffset();
		var sign = tzo < 0 ? '+' : '-';
		var hours = Math.floor(Math.abs(tzo) / 60);
		var minutes = Math.abs(tzo) % 60;
		var out = hours;
		if (token == 'zz') {
			out = zeroPad(hours);
		} else if (token == 'zzz') {
			out = zeroPad(hours) + ':' + zeroPad(minutes);
		}
		return sign + out;
	}

	function _getDesignator(getField, getSetting) {
		return getField(HOURS) < 12 ? getSetting('amDesignator') : getSetting('pmDesignator');
	}

	each(['getTime', 'valueOf', 'toDateString', 'toTimeString', 'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString', 'toJSON'], function (methodName) {
		proto[methodName] = function () {
			return this[0][methodName]();
		};
	});

	proto.setTime = function (t) {
		this[0].setTime(t);
		return this;
	};

	proto.valid = methodize(valid);
	function valid(xdate) {
		return !isNaN(xdate[0].getTime());
	}

	proto.clone = function () {
		return new XDate(this);
	};

	proto.clearTime = function () {
		return this.setHours(0, 0, 0, 0);
	};

	proto.toDate = function () {
		return new Date(this[0].getTime());
	};

	XDate.now = function () {
		return new Date().getTime();
	};

	XDate.today = function () {
		return new XDate().clearTime();
	};

	XDate.UTC = UTC;

	XDate.getDaysInMonth = getDaysInMonth;

	function _clone(xdate) {
		var d = new Date(xdate[0].getTime());
		if (getUTCMode(xdate)) {
			d.toString = toUTCString;
		}
		return d;
	}

	function _getField(d, useUTC, fieldIndex) {
		return d['get' + (useUTC ? 'UTC' : '') + methodSubjects[fieldIndex]]();
	}

	function _setField(d, useUTC, fieldIndex, args) {
		d['set' + (useUTC ? 'UTC' : '') + methodSubjects[fieldIndex]].apply(d, args);
	}

	function coerceToUTC(date) {
		return new Date(UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
	}

	function coerceToLocal(date) {
		return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
	}

	function getDaysInMonth(year, month) {
		return 32 - new Date(UTC(year, month, 32)).getUTCDate();
	}

	function methodize(f) {
		return function () {
			return f.apply(undefined, [this].concat(slice(arguments)));
		};
	}

	function curry(f) {
		var firstArgs = slice(arguments, 1);
		return function () {
			return f.apply(undefined, firstArgs.concat(slice(arguments)));
		};
	}

	function slice(a, start, end) {
		return Array.prototype.slice.call(a, start || 0, end === undefined ? a.length : end);
	}

	function each(a, f) {
		for (var i = 0; i < a.length; i++) {
			f(a[i], i);
		};
	}

	function isString(arg) {
		return typeof arg == 'string';
	}

	function isNumber(arg) {
		return typeof arg == 'number';
	}

	function isBoolean(arg) {
		return typeof arg == 'boolean';
	}

	function isFunction(arg) {
		return typeof arg == 'function';
	}

	function zeroPad(n, len) {
		len = len || 2;
		n += '';
		while (n.length < len) {
			n = '0' + n;
		}
		return n;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = XDate;
	}

	if (typeof define === 'function' && define.amd) {
		define([], function () {
			return XDate;
		});
	}

	return XDate;
}(Date, Math, Array);